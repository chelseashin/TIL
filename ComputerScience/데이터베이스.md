# 데이터베이스

##### DB를 사용하는 이유

::DB가 존재하기 전에는 파일 시스템을 이용하여 데이터를 관리하였음(현재도 부분적으로 사용함) 

데이터를 각각의 파일 단위로 저장하며 이러한 일들을 처리하기 위한 독립적인 애플리케이션과 상호 연동이 되어야함. 이 때의 문제점은 데이터 종속성 문제와, 중복성, 데이터 무결성이 있음.

##### DB 특징

1. 데이터 독립성
   - 물리적 독립성: DB 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 새롭게 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없음.
   - 논리적 독립성: DB는 논리적인 구조로 다양한 응용 프로그램의 논리적 요구를 만족시켜 줄 수 있음.
2. 데이터의 무결성: 여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능으로, 데이터의 유효성 검사를 통해 데이터의 무결성을 구현하게 됨.
3. 데이터 보안성: 인가된 사용자들만 데이터베이스나 데이터베이스 내의 자원에 접근할 수 있도록 계정 관리 또는 접근 권한을 설정함으로써 모든 데이터에 보안을 구현할 수 있음.
4. 데이터 일관성: 연관된 정보를 논리적인 구조로 관리함으로써 어떤 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있음. 또한 작업 중 일부 데이터만 변경되어 나머지 데이터와 일치하지 않는 경우의 수를 배제할 수 있음.
5. 데이터 중복 최소화: DB는 데이터를 통합해서 관리함으로써 파일 시스템의 단점 중 하나인 자료의 중복과 데이터의 중복성 문제를 해결함.

##### DB의 성능

::DB의 성능 이슈는 디스크 I/O를 어떻게 줄이느냐에서 시작됨. 디스크 I/O란 디스크 드라이브의 플래터(원판)을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미함. 이 때 데이터를 읽는데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정됨. 즉 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 따라 결정된다고 볼 수 있음. 그렇기 때문에 순차 I/O가 랜덤 I/O보다 빠를 수 밖에 없음. 하지만 현실에서는 대부분의 I/O작업이 랜덤 I/O임. 랜덤 I/O를 순차 I/O로 바꿔서 실행할 수는 없을까? 라는 생각에서부터 시작되는 DB 쿼리 튜닝은 랜덤 I/O자체를 줄여주는 것이 목적이라 할 수 있음.

##### Index

:: 인덱스는 말 그대로 책의 맨 처음 또는 마지막에 있는 색인 이라고 할 수 있음. 이 비유를 그대로 가져와서 인덱스를 살펴본다면, 데이터는 책의 내용이고 데이터가 저장된 레코드의 주소는 인덱스 목록에 있는 페이지 번호가 됨. DBMS(database management system)도 DB테이블의 무든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸림. 그래서 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어 두는 것. DBMS의 인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 탐색하는데는 빠르지만 새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려짐. 결론적으로 DBMS에서 인덱스는 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능임. SELECT쿼리 문장의 WHERE 조건절에 사용되는 칼럼이라고 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져서 오히려 역효과만 불러올 수 있음.

##### Index 자료구조

- B+ Tree 인덱스 알고리즘

  ::일반적으로 사용되는 인덱스 알고리즘은 B+ Tree 알고리즘임. B+ Tree 인덱스는 칼럼의 값을 변형하지 않고(사실 값의 앞부분만 잘라서 관리함) 원래의 값을 이용해 인덱싱하는 알고리즘임.

- Hash 인덱스 알고리즘

  ::칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원함. 하지만 값을 변형해서 인덱싱하므로, 특정 문자로 시작하는 값으로 검색을 하는 등 전방 일치와 같이 값의 일부만으로 검색하고자 할 때는 해시 인덱스를 사용할 수 없음. 주로 메모리 기반의 데이터베이스에서 많이 사용됨.

- 왜 index를 생성하는데 B Tree를 사용할까요?

  ::데이터에 접근하는 시간복잡도가 O(1)인 hash table이 효율적일것 같은데? SELCECT질의의 조건에서 부등호(<, >)연산도 포함이 된다. hash table을 사용하게 된다면 등호(=) 연산이 아닌 부등호 연산의 경우에 문제가 발생함. 따라서 동등 연산에 특화된 hashtable은 DB의 자료구조로 적합하지 않음.

##### Clustered Index

::클러스터(Cluster)란 여러 개를 하나로 묶는다는 의미로 주로 사용되는데, 클러스터드 인덱스도 크게 다르지 않음. 인덱스에서 클러스터드는 비슷한 것들을 묶어서 저장하는 형태로 구현되는데, 이는 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에서 착안된 것. 여기서 비슷한 값들은 물리적으로 인접한 장소에 저장되어 있는 데이터들을 말함.

클러스터드 인덱스는 테이블의 프라이머리 키에 대해서만 적용되는 내용임. 즉 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터드 인덱스라고 표현함. 클러스터드 인덱스에서는 프라이머리 키 값에 의해 레코드의 저장 위치가 결정되며, 프라이머리 키 값이 변경되면 그 레코드의 물리적인 저장 위치 또한 변경되어야함. 그렇기 때문에 프라이머리 키를 신중하게 결정하고 클러스터드 인덱스를 사용해야함. 클러스터드 인덱스는 테이블당 한 개 만 생성할 수 있음. 프라이머리 키에 대해서만 적용되기 때문, 이에 반해 non 클러스터드 인덱스는 테이블 당 여러 개를 생성할 수 있음

##### Composite Index

인덱스로 설정하는 필드의 속성이 중요함. title, author 이 순서로 인덱스를 설정한다면 title을 search하는 경우, index를 생성한 효과를 볼 수 있지만, author만으로 search 하는 경우, index를 생성한 것이 소용이 없어짐. 따라서 SELECT질의를 어떻게 할 것인가가 인덱스를 어떻게 생성할 것인가에 대해 많은 영향을 끼치게 됨.

##### Index의 성능과 고려사항

::SELECT 쿼리의 성능을 월등히 향상시키는 INDEX가 항상 좋은 것일까? 쿼리문의 성능을 향상 시킨다는데, 모든 칼럼에 INDEX를 생성해두면 빨라지지 않을까? **결론부터 말하자면 그렇지 않다.** 우선, 첫번째 이유는 INDEX를 생성하게 되면 INSERT, DELETE, UPDATE 쿼리문을 실행할 때 별도의 과정이 추가적으로 발생함. INSERT의 경우 INDEX에 대한 데이터도 추가해야 하므로 그만큼 성능에 손실이 따름. DELETE의 경우 INDEX에 존재하는 값은 삭제하지 않고 사용 안한다는 표시로 남게됨. 즉 row의 수는 그대로임. 이 작업이 반복되면 어떻게 될까?

실제 데이터는 10만건인데 데이터가 100만건 있는 결과를 낳을 수도 있음. 이렇게 되면 인덱스는 더이상 제 역할을 못하게됨. UPDATE의 경우 INSERT의 경우, DELETE의 경우의 문제점을 동시에 수반함. 이전 데이터가 삭제되고 그 자리에 새 데이터가 들어오는 개념이기 때문. 즉 변경 전 데이터는 삭제되지 않고 insert로 인한 split도 발생하게 됨.

하지만 더 중요한 것은 컬럼을 이루고 있는 데이터의 형식에 따라서 인덱스의 성능이 악영향을 미칠 수 있다는것. 즉, 데이터의 형식에 따라 인덱스를 만들면 효율적이고 만들면 비효율적인 데이터의 형식이 존재한다는 것. 어떤 경우에 그럴까?

이름, 나이, 성별 세가지의 필드를 갖고 있는 테이블을 생각해보자. 이름은 온갖 경우의 수가 존재할 것이며 나이는 INT타입을 가질것이고, 성별은 남,녀 두가지 경우에 대해서만 데이터가 존재할 것임을 쉽게 예측할 수 있음. 이 경우 어떤 칼럼에 대해서 인덱스를 생성하는 것이 효율적일까? 결론부터 말하자면 이름에 대해서만 인덱스를 생성하면 효율적이다. 왜 성별이나 나이는 인덱스를 생성하면 비효율적일까?

10000 레코드에 해당하는 테이블에 대해서 2000단위로 성별에 인덱스를 생성했다고 가정하자. 값의 range가 적은 성별은 인덱스를 읽고 다시 한 번 디스크 I/O가 발생하기 때문에 그만큼 비효율적인 것이다.??

##### 정규화

- 배경: 한 릴레이션에 여러 엔티티의 애트리뷰트들을 혼합하게 되면 정보가 중복 저장되며, 저장 공간을 낭비하게 된다. 또 중복된 정보로 인해 갱신이상이 발생하게 된다. 동일한 정보를 한 릴레이션에는 변경하고, 나머지 릴레이션에서는 변경하지 않은 경우 어느 것이 정확한지 알 수 없게 되는 것이다. 이러한 문제를 해결하기 위해 정규화 과정을 거치는 것이다.

- 갱신이상에는 어떠한 것들이 있는가?

  - 삽입이상(insertion anomalies): 원하지 않는 자료가 삽입된다든지, 삽입하는데 자료가 부족해 삽입이 되지 않아 발생하는 문제점.
  - 삭제이상(deletion anomalies): 하나의 자료만 삭제하고 싶지만, 그 자료가 포함된 튜플 전체가 삭제됨으로 원하지 않는 정보 손실이 발생하는 문제점.
  - 수정이상(modification anomalies): 정확하지 않거나 일부의 튜플만 갱신되어 정보가 모호해지거나 일관성이 없어져 정확한 정보 파악이 되지 않는 문제점.

- 그래서 정규화란?

  - 관계형 DB에서 중복을 최소화하기 위해 데이터를 구조화 하는 작업. 좀 더 구체적으로는 불만족스러운 나쁜 릴레이션의 애트리뷰트들을 나누어서 좋은 작은 릴레이션으로 분해하는 작업을 말함. 정규화 과정을 거치게 되면 정규형을 만족하게 됨. 정규형이란 특정 조건을 만족하는 릴레이션의 스키마의 형태를 말하며 제 1정규형, 제 2정규형, 제 3정규형, ... 등이 존재함.

  - 나쁜 릴레이션은 어떻게 파악하는가?

    :: 엔티티를 구성하고 있는 애트리뷰트 간에 함수적 종속성(Functional Depnedency)을 판단한다. 판단된 함수적 종속성은 좋은 릴레이션 설계의 정형적 기준으로 사용됨. 즉, 각각의 정규형마다 어떠한 함수적 종속성을 만족하는지에 따라 정규형이 정의되고, 그 정규형을 만족하지 못하는 정규형을 나쁜 릴레이션으로 파악함.

  - 함수적 종속성이란 무엇인가?

    ::함수적 종속성이란 애트리뷰트 데이터들의 의미와 애트리뷰트들 간의 상호 관계로부터 유도되는 제약조건의 일종. X와 Y를 임의의 애트리뷰트 집합이라고 할 때, X의 값이 Y의 값을 유일(unique)하게 결정한다면 "X는 Y를 함수적으로 결정한다"라고 한다. 함수적 종속성은 실세계에서 존재하는 애트리뷰트들 사이의 제약조건으로부터 유도됨. 또한 각종 추론 규칙에 따라서 애트리뷰트들 간의 함수적 종속성을 판단할 수 있음. *cf) 애트리뷰트 들의 관계로부터 추론된 함수적 종속성들을 기반으로 추론 가능한 모든 함수적 종속성들의 집합을 '폐포' 라고함*
    
  - 각각의 정규형은 어떠한 조건을 만족해야 하는가?
  
    - 분해의 대상인 분해집합 D는 무손실 조인을 보장해야함
    - 분해집함 D는 함수적 종속성을 보존해야함
  
- 제 1 정규형

  ::애트리뷰트의 도메인이 오직 원자값만을 포함하고, 튜플의 모든 애트리뷰트가 도메인에 속하는 하나의 값을 가져야 함. 즉, 복합 애트리뷰트, 다중값 애트리뷰트, 중첩 릴레이션 등 비원자적인 애트리뷰트들을 허용하지 않는 릴레이션 형태를 말함

- 제 2 정규형

  ::모든 비주요 애트리뷰트들이 주요 애트리뷰트에 대해서 완전 함수적 종속이면 제 2 정규형을 만족한다고 볼 수 있다. 완전 함수적 종속이란 x -> y 라고 가정했을 때, x의 어떠한 애트리뷰트라도 제거하면 더이상 함수적 종속성이 성립하지 않는 경우를 말한다. 즉, 키가 아닌 열들이 각각 후보키에 대해 결정되는 릴레이션 형태를 말한다. 

- 제 3 정규형

  ::어떠한 비주요 애트리뷰트도 기본키에 대해서 이행적으로 종속되지 않으면 제 3 정규형을 만족한다고 볼 수 있다. 이행 함수적 종속이란 x -> y, y -> z 의 경우에 의해서 추론될 수 있는 x -> z의 종속관계를 말한다. 즉, 비주요 애트리뷰트가 비주요 애트리뷰트에 의해 종속되는 경우가 없는 릴레이션 형태를 말한다.

- BCNF(Boyce-Codd) 정규형

  ::여러 후보키가 존재하는 릴레이션에 해당하는 정규화 내용이다. 복잡한 식별자 관계에 의해 발생하는 문제를 해결하기 위해 제 3 정규형을 보완하는데 의미가 있다. 비주요 애트리뷰트가 후보키의 일부를 결정하는 분해하는 과정을 말한다. 

- 각 정규형은 그의 선행 정규형보다 더 엄격한 정규형을 갖음.

  - 모든 제 2 정규형 릴레이션은 제 1 정규형을 갖음
  - 모든 제 3 정규형 릴레이션은 제 2 정규형을 갖음
  - 모든 BCNF 정규형 릴레이션은 제 3 정규형을 갖음

- 수많은 정규형이 있지만 관계 DB 설계의 목표는 각 릴레이션이 3NF(or BCNF)를 갖게 하는 것.



- 정규화에는 어떠한 장점이 있는가?

1. DB 변경시 이상현상(Anomaly) 제거: 위에서 언급했던 각종 이상현상들이 발생하는 문제점을 해결할 수 있다.
2. DB구조 확장시 재 디자인 최소화: 정규화된 DB 구조에서는 새로운 데이터형의 추가로 인한 확장시, 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다. 이는 DB와 연동된 응용 프로그램에 최소한의 영향만을 미치게 되며 응용 프로그램의 생명을 연장시킨다.
3. 사용자에게 데이터 모델을 더욱 의미있게 제공: 정규화된 테이블들과 정규화된 테이블들간의 관계들은 현실 세계에서의 개념들과 그들간의 관계들을 반영한다.

- 단점은 없는가?

::릴레이션의 분해로 인해 릴레이션 간의 연산(JOIN 연산)이 많아진다. 이로인해 질의에 대한 응답 시간이 느려질 수 있다. 조금 덧붙이자면, 정규화를 수행한다는 것은 데이터를 결정하는 결정자에 의해 함수적 종속을 갖고 있는 일반 속성을 의존자로 하여 입력/수정/삭제 이상을 제거하는 것이다. 데이터의 중복 속성을 제거하고 결정자에 의해 동일한 의미의 일반 속성이 하나의 테이블로 집약되므로 한 테이블의 데이터 용량이 최소화되는 효과가 있다. 따라서 정규화된 테이블은 데이터를 처리할 때 속도가 빨라질 수도 있고 느려질 수도 있는 특성이 있다.

- 단점으로 미루어보았을 때 어떠한 상황에서 정규화를 진행해야 하는가? 단점에 대한 대응책은?

:: 조회를 하는 SQL 문장에서 조인이 많이 발생하여 이로 인한 성능저하가 나타나는 겨웅에 반정규화를 적용하는 적략이 필요함.

- 반정규화(De-normalization, 비정규화)

  ::반정규화는 정규화된 엔티티, 속성, 관계를 시스템의 성능 향상 및 개발과 운영의 단순화를 위해 중복 통합, 분리 등을 수행하는 데이터 모델링 기법 중 하나이다. 디스크 I/O량이 많아서 조회시 성능이 저하되거나, 테이블끼리 경로가 너무 멀어 조인으로 인한 성능 저하가 예상되거나, 칼럼을 계산하여 조회할 때 성능이 저하될 것이 예상되는 경우 반정규화를 수행하게 된다. 일반적으로 조회에 대한 처리 성능이 중요하다고 판단될 때 부분적을 ㅗ반정규화를 고려하게 된다.

- 무엇이 반정규화의 대상이 되는가?

1. 자주 사용되는 테이블에 액세스하는 프로세스의 수가 가장 많고, 항상 일정한 범위만을 조회하는 경우
2. 테이블에 대량 데이터가 있고 대량의 범위를 자주 처리하는 경우, 성능 상 이슈가 있을 경우
3. 테이블에 지나치게 조인을 많이 사용하게 되어 데이터를 조회하는 것이 기술적으로 어려울 경우

- 반정규화 과정에서 주의할 점은?

  ::반정규화를 과도하게 적용하다 보면 데이터의 무결성이 깨질 수 있다. 또한 입력, 수정, 삭제의 질의문에 대한 응답 시간이 늦어질 수 있다.



##### Transaction(트랜잭션)

- 트랜잭션이란 무엇인가?

::트랜잭션은 작업의 **완전성**을 보장해주는 것. 즉, 논리적인 작업 셋을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능. 사용자의 입장에서는 작업의 논리적 단위로 이해를 할 수 있고 시스템의 입장에서는 데이터들을 접근 또는 변경하는 프로그램의 단위가 됨.

- 트랜잭션과 Lock

::Lock(잠금)과 트랜잭션은 서로 비슷한 개념 같지만 사실 잠금은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다. 잠금은 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다. (여기서 자원은 레코드나 테이블을 말한다.) 이와는 다르게 트랜잭션은 꼭 여러 개의 변경 작업을 수행하는 쿼리가 조합되었을 때만 의미있는 개념은 아니다. 트랜잭션은 하나의 논리적인 작업 셋 중 하나의 쿼리가 있든 두 개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장하는 것이다. 예를 들면 HW 에러 또는 SW에러 같은 문제로 인해 작업에 실패가 있을 경우 특별한 대책이 필요하게 되는데, 이러한 문제를 해결하는 것이다.

- 트랜잭션의 특성:: 트랜잭션은 ACID라는 4가지 특성을 만족해야 한다.

1. 원자성(Atomicity): 만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.

2. 일관성(Consistency): 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.

3. 고립성(Isolation): 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.

4. 지속성(Durability): 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.

   

- 트랜잭션의 상태

[![트랜잭션 상태 다이어그램](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/raw/master/Database/images/transaction-status.png)](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/blob/master/Database/images/transaction-status.png)

1. Active: 트랜잭션의 활동 상태. 트랜잭션이 실행중이며 동작중인 상태를 말함.
2. Failed: 트랜잭션 실패 상태. 트랜잭션이 더이상 정상적으로 진행 할 수 없는 상태를 말함.
3. Partially Comitted: 트랜잭션의 commit 명령이 도착한 상태. 트랜잭션의 commit 이전 sql 문이 수행되고 commit만 남은 상태를 말함.
4. Committed: 트랜잭션 완료 상태. 트랜잭션이 정상적으로 완료된 상태를 말함.
5. Aborted: 트랜잭션 취소 상태. 트랜잭션이 취소되고 트랜잭션 실행 이전 데이터로 돌아간 상태를 말함.

cf) Partially Committed와 committed의 차이점

:: commit 요청이 들어오면 상태는 Partial Commited 상태가 된다. 이후 commit을 문제없이 수행할 수 있으면 committed상태로 전이되고, 만약 오류가 발생하면 Failed가 된다. 즉, Partial Committed는 commit 요청이 들어왔을때를 말하며, commited는 commit을 정상적으로 완료한 상태를 말한다.

- 트랜잭션 사용시 주의사항

::트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋다. 즉 트랜잭션의 범위를 최소화하라는 의미다. 일반적으로 DB 커넥션은 개수가 제한적이다. 그런데 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 사용 가능한 여유 커넥션의 개수는 줄어들게 된다. 그러다 어느 순간에는 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수도 있는 것이다.

- 교착상태

:: 복수의 트랜잭션을 사용하다보면 교착상태가 일어날 수 있다. 교착상태란 두 개 이상의 트랜잭션이 특정자원(테이블 또는 행)의 잠금(Lock)을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상태가 되는데, 이를 교착상태라고 한다.

- 교착상태의 예(MySQL)

MySQL [MVCC](https://en.wikipedia.org/wiki/Multiversion_concurrency_control)에 따른 특성 때문에 트랜잭션에서 갱신 연산(Insert, Update, Delete)를 실행하면 잠금을 획득한다. (기본은 행에 대한 잠금)

[![classic deadlock 출처: https://darkiri.wordpress.com/tag/sql-server/](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/raw/master/Database/images/deadlock.png)](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/blob/master/Database/images/deadlock.png)

트랜잭션 1이 테이블 B의 첫번째 행의 잠금을 얻고 트랜잭션 2도 테이블 A의 첫번째 행의 잠금을 얻었다고 하자.

```
Transaction 1> create table B (i1 int not null primary key) engine = innodb;
Transaction 2> create table A (i1 int not null primary key) engine = innodb;

Transaction 1> start transaction; insert into B values(1);
Transaction 2> start transaction; insert into A values(1);
```

트랜잭션을 commit 하지 않은채 서로의 첫번째 행에 대한 잠금을 요청하면

```
Transaction 1> insert into A values(1);
Transaction 2> insert into B values(1);
ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction
```

Deadlock 이 발생한다. 일반적인 DBMS는 교착상태를 독자적으로 검출해 보고한다.

- 교착상태의 빈도를 낮추는 방법
  - 트랜잭션을 자주 커밋한다.
  - 정해진 순서로 테이블에 접근한다. 위에서 트랜잭션 1이 테이블 B->A순으로 접근했고, 트랜잭션 2는 테이블 A->B의 순으로 접근했다. 트랜잭션들이 동일한 테이블 순으로 접근하게 한다.
  - 읽기 잠금 획득(SELECT ~ FOR UPDATE)의 사용을 피한다.
  - 한 테이블의 복수행을 복수의 연결에서 순서없이 갱신하면 교착상태가 발생하기 쉽다. 위 경우에는 테이블 단위의 잠금을 획득해 갱신을 직렬화 하면 동시성은 떨어지지만 교착상태를 회피할 수 있다.

##### Statement vs PreparedStatement

:: 우선 속도 면에서 PreparedStatement가 빠르다고 알려져 있다. 이유는 쿼리를 수행하기 전에 이미 쿼리가 컴파일 되어 있으며, 반복 수행의 경우 프리 컴파일된 쿼리를 통해 수행이 이루어지기 때문이다.

PreparedStatement에는 보통 변수를 설정하고 바인딩하는 static sql이 사용되고 Statement에서는 쿼리 자체에 조건이 들어가는 dynamic sql이 사용된다. PreparedStatement가 파싱 타임을 줄여주는 것은 분명하지만 static sql을 사용하는데 따르는 퍼포먼스 저하를 고려하지 않을 수 없다. 

하지만 성능을 고려할 때 시간 부분에서 가장 큰 비중을 차지하는 것은 테이블에서 레코드(row)를 가져오는 과정이고 SQL문을 파싱하는 시간은 이 시간의 10분의 1에 불과하다. 그렇기 때문에 SQL Injection 등의 문제를 보완해주는 PreparedStatement를 사용하는 것이 옳다.

---

##### NoSQL ?? 일단 보류

https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database#statement-vs-preparedstatement

---

##### 데이터베이스 풀

- Connection pool
  - 클라이언트 요청에 따라 각 어플리케이션의 스레드에서 DB에 접근하기 위해서는 Connection이 필요하다.
  - Connection pool은 이런 Connection을 여러개 생성해두어 저장해 놓은 **공간(캐시)**, 또는 이 공간의 Connection을 필요할 때 꺼내 쓰고 반환하는 **기법**을 말한다.

[![img](https://github.com/WeareSoft/tech-interview/raw/master/contents/images/db-img/db-connection-02.png)](https://github.com/WeareSoft/tech-interview/blob/master/contents/images/db-img/db-connection-02.png)

- DB에 접근하는 단계
  1. 웹 컨테이너가 실행되면서 DB와 연결된 Connection 객체들을 미리 생성하여 pool에 저장한다.
  2. DB에 요청시, pool에서 Connection 객체를 가져와 DB에 접근한다.
  3. 처리가 끝나면 다시 pool에 반환한다.

[![img](https://github.com/WeareSoft/tech-interview/raw/master/contents/images/db-img/db-connection-01.jpeg)](https://github.com/WeareSoft/tech-interview/blob/master/contents/images/db-img/db-connection-01.jpeg)

- Connection이 부족하면?
  - 모든 요청이 DB에 접근하고 있고 남은 Connection이 없다면, 해당 클라이언트는 대기상태로 전환시키고 Pool에 Connection이 반환되면 대기상태에 있는 클라이언트에게 순차적으로 제공된다.
- 왜 사용할까?
  - 매 연결마다 Connection 객체를 생성하고 소멸시키는 비용을 줄일 수 있다.
  - 미리 생성된 Connection 객체를 사용하기 때문에, DB 접근 시간이 단축된다.
  - DB에 접근하는 Connection의 수를 제한하여, 메모리와 DB에 걸리는 부하를 조정할 수 있다.
- Thread Pool
  - 비슷한 맥락으로 Thread pool이라는 개념도 있다.
  - 이 역시 매 요청마다 요청을 처리할 Thread를 만드는것이 아닌, 미리 생성한 pool내의 Thread를 소멸시키지 않고 재사용하여 효율적으로 자원을 활용하는 기법.
- Thread Pool과 Connection Pool
  - WAS에서 Thread pool과 Connection pool내의 Thread와 Connection의 수는 직접적으로 메모리와 관련이 있기 때문에, 많이 사용하면 할수록 메모리를 많이 점유하게 된다. 그렇다고 반대로 메모리를 위해 적게 지정한다면, 서버에서는 많은 요청을 처리하지 못하고 대기할 수 밖에 없다.
  - 보통의 WAS의 Thread의 수가 Connection의 수보다 많은 것이 좋은데, 그 이유는 모든 요청이 DB에 접근하는 작업이 아니기 때문이다.

##### 트랜잭션

- 트랜잭션이란?

  - DB의 상태를 변환시키는 하나의 논리적인 작업 단위를 구성하는 연산들의 집합.
    - 예를들어, A계좌에서 B계좌로 일정 금액을 이체한다고 가정하자.
      1. A계좌의 잔액을 확인한다.
      2. A계좌의 금액에서 이체할 금액을 빼고 다시 저장한다.
      3. B계좌의 잔액을 확인한다.
      4. B계좌의 금액에서 이체할 금액을 더하고 다시 저장한다.
    - 이러한 과정들이 모두 합쳐져 계좌이체라는 하나의 작업단위를 구성한다.
  - 하나의 트랜잭션은 Commit 되거나 Rollback 된다.
    - Commit 연산
      - 한개의 논리적 단위(트랜잭션)에 대한 작업이 성공적으로 끝나 DB가 다시 일관된 상태에 있을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산.
    - Rollback 연산
      - 하나의 트랜잭션 처리가 비정상적으로 종료되어 DB의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소(Undo)하는 연산이다.
      - Rollback 시에는 해당 트랜잭션을 재시작하거나 폐기한다.
  - DB 응용 프로그램은 트랜잭션들의 집합으로 정의할 수 있다.

- 트랜잭션의 성질(ACID)

  - 원자성(Atomicity), All or nothing
    - 트랜잭션의 모든 연산들은 정상적으로 수행 완료되거나 아니면 전혀 어떠한 연산도 수행되지 않은 상태를 보장해야 한다.
  - 일관성(Consistency)
    - 트랜잭션 완료 후에도 DB가 일관된 상태로 유지되어야 한다.
  - 독립성(Isolation)
    - 하나의 트랜잭션이 실행하는 도중에 변경한 데이터는 이 트랜잭션이 완료될때까지 다른 트랜잭션이 참조하지 못한다.
  - 지속성(Durability)
    - 성공적으로 수행된 트랜잭션은 영원히 반영되어야 한다.

- 트랜잭션의 필요성

  - 현금 인출기를 작동하는 도중에 기계오류나 정전 등과 같은 예기치 않은 상황이 발생하여 카드가 나오지 않거나 기계가 멈추는 경우
  - 각각 다른 지점의 은행에서 동시에 인출할 때, 하나의 지점이 다른 지점에서 저장한 잔액을 덮어 쓰는 경우
  - 위와 같은 상황이 발생되지 않도록 방지하기 위해, 즉, 트랜잭션의 성질인 ACID를 제공받기위해 트랜잭션을 사용한다.

- 트랜잭션의 상태

  [![img](https://github.com/WeareSoft/tech-interview/raw/master/contents/images/transaction-status.png)](https://github.com/WeareSoft/tech-interview/blob/master/contents/images/transaction-status.png)
  - 활동(Active)
    - 트랜잭션이 실행 중에 있는 상태, 연산들이 정상적으로 실행중인 상태
  - 장애(Failed)
    - 트랜잭션이 실행에 오류가 발생하여 중단된 상태
  - 철회(Aborted)
    - 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태
  - 부분완료(Partially Committed)
    - 트랜잭션이 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태
  - 완료(Committed)
    - 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태

##### 트랜잭션 격리 수준

- Isolation Level 이란?

  - 트랜잭션에서 일관성이 없는 데이터를 허용하도록 하는 수준

- Isolation Level의 필요성

  - DB는 ACID같이 트랜잭션이 원자적이면서도 독립적인 수행을 하도록 한다.
  - 그래서 Locking 이라는 개념이 등장한다. -> 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하게 막는 것.
  - 하지만 무조건적인 Locking으로 동시에 수행되는 많은 트랜잭션들을 순서대로 처리하는 방식으로 구현되면 DB의 성능은 떨어지게 된다.
  - 반대로 응답성을 높이기 위해 Locking의 범위를 줄인다면 잘못된 값이 처리될 여지가 있다.
  - 그래서 최대한 효율적인 Locking 방법이 필요하다

- Isolation Level의 종류

  1. Read Uncommitted(레벨 0)
     - SELECT 문장이 수행되는 동안 데이터에 Shared Lock이 걸리지 않는 Level
     - 트랜잭션에 처리중인 혹은 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다.
     - 따라서, 어떤 사용자가 A라는 데이터를 B라는 데이터로 변경하는 동안 다른 사용자는 아직 완료되지 않은(Uncommitted 혹은 Dirty) 트랜잭션이지만 변경된 데이터인 B를 읽을 수 있다.
     - DB의 일관성을 유지할 수 없다.
  2. Read Committed(레벨 1)
     - SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리는 Level
     - 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 된다.
     - Commit이 이루어진 트랜잭션만 조회할 수 있다.
     - 따라서, 어떤 사용자가 A라는 데이터를 B라는 데이터로 변경하는 동안 다른 사용자는 해당 데이터에 접근할 수 없다.
     - SQL Server가 Default로 사용하는 Isolation Level
  3. Repeatable Read(레벨 2)
     - 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 Level
     - 트랜잭션이 범위 내에서 조회한 데이터의 내용이 항상 동일함을 보장함.
     - 따라서, 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정이 불가능함.
  4. Serializable(레벨 3)
     - 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 level
     - 완벽한 일기 일관성 모드를 제공함.
     - 따라서, 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정 및 입력이 불가능함.

  cf) Isolation Level 조정은 동시성이 증가되는데 반해 데이터 무결성에 문제가 발생할 수 있고, 데이터의 무결성을 유지하는데 반해 동시성이 떨어질 수 있다, 레벨이 높아질수록 비용이 높아진다.

- 낮은 단계의 Isolation Level 이용시 발생하는 현상

  [![img](https://github.com/WeareSoft/tech-interview/raw/master/contents/images/isolation-level.png)](https://github.com/WeareSoft/tech-interview/blob/master/contents/images/isolation-level.png)

  - Dirty Read
    - 커밋되지 않은 수정중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 현상
    - 어떤 트랜잭션에서 아직 실행이 끝나지 않은 다른 트래잭션에 의한 변경사항을 보게되는 경우
  - Non-Repeatable Read
    - 한 트랜잭션에서 같은 쿼리를 두번 수행할 때 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제함으로써 두 쿼리의 결과가 상이하게 나타나는 비일관성 현상
  - Phantom Read
    - 한 트랜잭션 안에서 일정 범위의 레코드를 두번 이상 읽을 때, 첫번쨰 쿼리에서 없던 레코드가 두번째 쿼리에서 나타나는 현상
    - 이는 트랜잭션 도중 새로운 레코드가 삽입되는 것을 허용하기 때문에 나타난다.

##### Join

- 조인이란
  - **한 DB내의 여러 테이블의 레코드를 조합하여 하나의 열로 표현한 것.**
  - 따라서 조인은 테이블로서 저장되거나, 그 자체로 이용할 수 있는 결과 셋을 만들어 낸다.
- 조인의 필요성
  - 관계형 DB의 구조적 특징으로 정규화를 수행하면 의미있는 데이터의 집합으로 테이블이 구성되고, 각 테이블끼리는 관계(Relationship)를 갖게 된다.
  - 이와같은 특징으로 관계형 DB는 저장 공간의 효율성과 확장성이 향상되게 된다.
  - 다른 한편으로는 서로 관계있는 데이터가 여러 테이블로 나뉘어 저장되므로, 각 테이블에 저장된 데이터를 효과적으로 검색하기 위해 조인이 필요하다.

[![img](https://github.com/WeareSoft/tech-interview/raw/master/contents/images/join-table.png)](https://github.com/WeareSoft/tech-interview/blob/master/contents/images/join-table.png)

조인의 종류

1. 내부 조인(Inner join)

   - 여러 애플리케이션에서 사용되는 가장 흔한 결합 방식이며, 기본 조인 형식으로 간주된다.

   - 내부 조인은 조인 구문에 기반한 2개의 테이블(A, B)의 컬럼 값을 결합함으로써 새로운 결과 테이블을 생성한다.

   - 명시적 조인 표현(explicit)과 암시적 조인 표현(implicit) 2개의 다른 조인식 구문이 있다.

   - 명시적 조인 표현(explicit)

     - 테이블에 조인을 하라는 것을 지정하기 위해 JOIN키워드를 사용하며, 그리고나서 다음의 예제와 같이 ON 키워드를 조인에 대한 구문을 지정하는데 사용한다.

     ```
     SELECT *
     FROM employee INNER JOIN department
     ON employee.DepartmentID = department.DepartmentID;
     ```

   - 암시적 조인 표현(implicit)

     - SELECT 구문의 FROM 절에서 그것을 분리하는 컴마를 사용해서 단순히 조인을 위한 여러 테이블을 나열하기만 한다.

     ```
     SELECT *
     FROM employee, department
     WHERE employee.DepartmentID = department.DepartmentID;
     ```

   - 결과
     [![img](https://github.com/WeareSoft/tech-interview/raw/master/contents/images/inner-join.png)](https://github.com/WeareSoft/tech-interview/blob/master/contents/images/inner-join.png)

   1. 동등 조인(EQUI JOIN)

      - 비교자 기반의 조인이며, 조인 구문에서 동등(=)비교만을 사용

   2. 자연 조인(NATURAL JOIN)

      - 동등 조인의 한 유형으로 조인 구문이 조인된 테이블에서 동일한 컬럼명을 가진 2개의 테이블에서 모든 컬럼들을 비교함으로써, 암시적으로 일어나는 구문이다.
      - 결과적으로 나온 조인된 테이블은 동일한 이름을 가진 컬럼의 각 쌍에 대한 단 하나의 컬럼만 포함하고 있다.

      - SQL

        ```
        SELECT * FROM employee NATURAL JOIN department;
        ```

      - 결과
        [![img](https://github.com/WeareSoft/tech-interview/raw/master/contents/images/natural-join.png)](https://github.com/WeareSoft/tech-interview/blob/master/contents/images/natural-join.png)

   3. 교차 조인(CROSS JOIN)

      - 조인되는 두 테이블에서 곱집합을 반환한다.
      - 즉, 두번째 테이블로부터 각 행과 첫번쨰 테이블에서 각 행이 한번씩 결합된 열을 만드는 것이다.
      - 예를들어 m행을 가진 테이블과 n행을 가진 테이블이 교차 조인되면 m*n개의 행을 생성한다.

      - 명시적 조인 표현

        ```
        SELECT * FROM employee CROSS JOIN department;
        ```

      - 암시적 조인 표현

        ```
        SELECT * FROM employee, department;
        ```

      - 결과
        [![img](https://github.com/WeareSoft/tech-interview/raw/master/contents/images/cross-join.png)](https://github.com/WeareSoft/tech-interview/blob/master/contents/images/cross-join.png)

2. 외부 조인(OUTER JOIN)

   - 조인 대상 테이블에서 **특정 테이블의 데이터가 모두 필요한 상황**에서 외부 조인을 활용하여 효과적으로 결과 집합을 생성할 수 있다.

   - 왼쪽 외부 조인(LEFT OUTER JOIN)

     - 좌측 테이블의 모든 데이터를 포함하는 결과 집합을 생성한다.

     - SQL

       ```
       SELECT *
       FROM employee LEFT OUTER JOIN department
       ON employee.DepartmentID = department.DepartmentID;
       ```

     - 결과
       [![img](https://github.com/WeareSoft/tech-interview/raw/master/contents/images/left-outer-join.png)](https://github.com/WeareSoft/tech-interview/blob/master/contents/images/left-outer-join.png)

   - 오른쪽 외부 조인(RIGHT OUTER JOIN)

     - 위 left outer join에서 참조하는 테이블이 반대

   - 완전 외부 조인(FULL OUTER JOIN)

     - 양쪽 테이블 모두 OUTER JOIN이 필요할 때 사용한다.

     - SQL

       ```
       SELECT *
       FROM employee FULL OUTER JOIN department
       ON employee.DepartmentID = department.DepartmentID;
       ```

     - 결과
       [![img](https://github.com/WeareSoft/tech-interview/raw/master/contents/images/full-outer-join.png)](https://github.com/WeareSoft/tech-interview/blob/master/contents/images/full-outer-join.png)

3. 셀프 조인(SELF JOIN)

   - 한 테이블에서 자기 자신에 조인을 시키는 것이다.

조인 사용시 주의사항

- SQL문장의 의미를 제대로 파악
  - SQL을 어떻게 작성하느냐에 따라 성능이 크게 좌우된다. 어떤 질의를 수행할것인지를 명확하게 정의한 후, 비효율을 제거하여 최적의 SQL을 작성해야 한다.
- 명확한 조인 조건 제공
  - 조인 조건을 명확하게 제공하지 않을 경우, 의도치 않게 CROSS JOIN이 수행될 수 있다.

조인을 사용할 때 고려사항

- 조인할 대상의 집합을 최소화
  - 집합을 최소화할 방법이 있으면, 조건을 먼저 적용하여 관계를 맺을 집합을 최소화한 후, 조인을 맺는 것이 효율적이다.
- 효과적인 인덱스의 활용
  - 인덱스를 활용하면, 조인 연산의 비용을 극적으로 낮출 수 있다.

##### Index란

::DB에서 조회 및 검색을 더 빠르게 할 수 있는 방법/기술 혹은 이에 쓰이는 자료구조 자체를 의미하기도 한다.

- 사용 이유
  - select문을 사용하여 원하는 조건의 데이터를 검색할 때, 저장된 데이터의 양이 엄청나게 많다면 검색을 위한 순회에 많은 자원과 시간이 소모될 것이다. 이때 도움이 되는게 인덱스이다. 자주 조회되는 Column에 대한 Index Table을 따로 만들어 SELECT문이 들어왔을 때 Index 테이블에 있는 값들로 결과 값을 조회해 온다. 그래서 Index를 잘 사용한다면 "검색" 연산을 실행했을 때 성능을 올릴 수 있게 된다.
- 동작
  - Index Table에서 where에 포함된 값을 검색
  - 해당 값의 table_id PK를 획득
  - 가져온 table_id PK값으로 원본 테이블에서 값을 조회
- DBMS는 인덱스를 다양한 알고리즘으로 관리를 하고 있는데 일반적으로 사용되는 알고리즘은 B+ Tree 알고리즘이다.

##### B+tree 알고리즘

[![img](https://github.com/WeareSoft/tech-interview/raw/master/contents/images/db-btree.png)](https://github.com/WeareSoft/tech-interview/blob/master/contents/images/db-btree.png)

- 실제 데이터가 저장된 리프노드(leaf nodes), 리프노드까지의 경로 역할을 하는 논리프노드(non-leaf nodes), 경로의 출발점이 되는 루트노드(root node)
- B+ tree는 리프노드에 이르기까지에 대한 자식 노드에 포인터가 저장되어 있다. 즉, B+ 트리의 검색은 루트노드에서 어떤 리프노드에 이르는 한개의 경로만 검색하면 되므로 매우 효율적이다.
- B+ tree 사용 이유
  - 왜 index 생성시 b-tree를 사용하는지? hash table이 효율적이지 않은지?
    - SELECT 질의 조건에는 부등호 연산(<, >)도 포함
    - hash table은 동등 연산에 특화된 자료구조이기 때문에 부등호 연산 사용시 문제 발생
- 주의할 점
  - 인덱스는 따로 테이블의 형태로 관리가 된다. 자원을 소모한다는 의미. 때문에 무분별한 인덱스의 사용은 성능에 부정적인 영향을 미칠 수 있다.
  - 또한 인덱스는 이진트리를 사용하기 때문에 기본적으로 정렬되어 있다.(??b-tree가 n진트리 아니고?)이로인해 검색과 조회의 속도를 향상시킬 수 ㅣㅇㅆ지만 잦은 데이터의 변경(삽입, 삭제, 수정)가 된다면 인덱스 테이블을 변경과 정렬에 드는 오버헤드 때문에 오히려 성능 저하가 일어날 수 있다.
    - INSERT: 테이블에는 입력 순서대로 저장되지만, 인덱스 테이블에는 정렬하여 저장하기 때문에 성능 저하 발생
    - DELETE: 테이블에서만 삭제되고 인덱스 테이블에는 남아있어 쿼리 수행 속도 저하
    - UPDATE: 인덱스에는 UPDATE가 없기 때문에 DLELTE, INSERT 두 작업 수행하여 부하 발생
  - 데이터의 중복이 높은 컬럼(카디널리티가 낮은 컬럼)은 인덱스로 만들어도 무용지물(Ex: 성별)
  - 다중 컬럼 인덱싱할 때 카디널리티가 높은 컬럼 -> 낮은 컬럼 순으로 인덱싱해야 효율적

##### 파티셔닝

- 배경
  - 서비스의 크기가 점점 커지고 DB에 저장하는 데이터의 규모 또한 대용량화 되면서, 기존에 사용하는 DB 시스템의 용량(storage)의 한계와 성능(performance)의 저하를 가져오게 되었다.
  - 즉, VLDB(Very Large DBMS)와 같이 하나의 DBMS에 너무 큰 table이 들어가면서 용량과 성능 측면에서 많은 이슈가 발생하게 되었고, 이런 이슈를 해결하기 위한 방법으로 table을 파티션(partition)이라는 작은 단위로 나누어 관리하는 파티셔닝 기법이 나타나게 되었다.
- 파티셔닝의 개념
  - 큰 table이나 index를 관리하기 쉬운 partition이라는 작은 단위로 물리적으로 분할하는 것을 의미.
    - 물리적인 데이터 분할이 있더라도, DB에 접근하는 application의 입장에서는 이를 인식하지 못함.
  - 파티셔닝 기법을 통해 소프트웨어적으로 DB를 분산처리하여 성능이 저하되는 것을 방지하고 관리를 보다 수월하게 할 수 있게 되었다.
- 파티셔닝의 목적
  1. 성능(Performance)
     - 특정 DML과 Query의 성능을 향상시킨다.
     - 주로 대용량 data WRITE환경에서 효율적이다.
     - 특히, Full Scan에서 데이터 Access의 범위를 줄여 성능 향상을 가져온다.
     - 많은 INSERT가 있는 OLTP 시스템에서 INSERT작업을 작은 단위인 partition들로 분산시켜 경합을 줄인다.
  2. 가용성(Availability)
     - 물리적인 파티셔닝으로 인해 전체 데이테의 훼손 가능성이 줄어들고 데이터 가용성이 향상된다.
     - 각 분할 영역(partition별로)을 독립적을 백업하고 복구할 수 있다.
     - table의 partition단위로 Disk I/O를 분산하여 경합을 줄이기 때문에 UPDATE성능을 향상시킨다.
  3. 관리용이성(Manageability)
     1. 큰 table들을 제거하여 관리를 쉽게 해준다.
- 파티셔닝의 단점
  - table간 JOIN에 대한 비용이 증가한다.
  - table과 index를 별도로 파티셔닝할 수 없다.(table과 index를 같이 파티셔닝 해야한다.)
- 파티셔닝의 종류
  1. 수평(horizontal) 파티셔닝(샤딩(Sharding)과 동일한 개념)
  2. 수직(vertical) 파티셔닝

[![img](https://github.com/WeareSoft/tech-interview/raw/master/contents/images/types-of-partitioning.png)](https://github.com/WeareSoft/tech-interview/blob/master/contents/images/types-of-partitioning.png)

- 파티셔닝의 분할 기준
  - 범위 분할(range partitioning)
  - 목록 분할(list partitioning)
  - 해시 분할(hash partitioning)
  - 합성 분할(composite partitioning)

##### ORM(Object-Relational Mapping)

::객체와 관계형 DB의 데이터를 자동으로 매핑해주는 것을 말한다.

- 영속성(Persistence)

  - 데이터를 생성한 프로그램의 실행이 종료되더라도 사라지지 않는 데이터의 특성.
  - 영속성을 갖지 않는 데이터는 단지 메모리에서만 존재하기 때문에 프로그램을 종료하면 모두 잃어버리게 된다. 때문에 파일 시스템, 관계형 DB 혹은 객체 DB등을 활용하여 데이터를 영구하게 저장하여 영속성을 부여한다.

- Persistence layer

  ::프로그램의 아키텍처에서, 데이터에 영속성을 부여해주는 계층. JDBC를 이용하여 직접 구현할 수 있지만 Persistence framework를 이용한 개발이 많이 이루어진다.

[![img](https://github.com/WeareSoft/tech-interview/raw/master/contents/images/persistence-layer.png)](https://github.com/WeareSoft/tech-interview/blob/master/contents/images/persistence-layer.png)

- Persistence framework

  ::JDBC 프로그래밍의 복잡함이나 번거로움 없이 간단한 작업만으로 DB와 연동되는 시스템을 빠르게 개발할 수 있으며 안정적인 구동을 보장한다.

  - 종류
    - SQL 문장으로 직접 DB 데이터를 다루는 SQL 맵퍼 Ex) Mybatis 등
    - **객체를 통해 간접적으로 DB 데이터를 다루는 객체 관계 맵퍼(ORM)** Ex) Hibernate 등

- 장점(왜 사용하는가?)

  - 객체 지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 더 집중할 수 있게 도와준다.
    - 선언문, 할당, 종료 같은 부수적인 코드가 없거나 급격히 줄어든다.
    - 각종 객체에 대한 코드를 별도로 작성하기 때문에 코드의 가독성을 올려준다.
    - SQL의 절차적이고 순차적인 접근이 아닌 객체 지향적인 접근으로 인해 생산성이 증가한다.

  - 재사용 및 유지보수의 편리성이 증가한다.
    - ORM은 독립적으로 작성되어 있고, 해당 객체들을 재활용 할 수 있다.
    - 때문에 모델에서 가공된 데이터를 컨트롤러에 의해 뷰와 합쳐지는 형태로 디자인 패턴을 견고하게 다지는데 유리하다.
    - 매핑정보가 명확하여, ERD를 보는 것에 대한 의존도를 낮출 수 있다.
  - DBMS에 대한 종속성이 줄어든다.
    - 대부분 ORM 솔루션은 DB에 종속적이지 않다.
    - 종속적이지 않다는 것은 구현 방법 뿐만아니라, 많은 솔루션에서 자료형 타입까지 유효하다.
    - 프로그래머는 Object에 집중함으로 극단적으로 DBMS를 교체하는 거대한 작업에도 비교적 적은 리스크와 시간이 소요된다.
    - 또한 자바에서 가공할 경우 equals, hashCode의 오버라이드 같은 자바의 기능을 이용할 수 있고, 간결하고 빠른 가공이 가능하다.

- 단점

  - 완벽한 ORM으로만 서비스를 구현하기가 어렵다.
    - 사용하기는 편하지만 설계는 매우 신중하게 해야한다.
    - 프로젝트의 복잡성이 커질경우 난이도 또한 올라갈 수 있다.
    - 잘못 구현된 경우에 속도 저하 및 심각할 경우 일관성이 무너지는 문제점이 생길 수 있다.
    - 일부 자주 사용되는 대형 쿼리는 속도를 위해 SP를 쓰는등 별도의 튜닝이 필요한 경우가 있다.
    - DBMS의 고유 기능을 이용하기 어렵다.(하지만 이건 단점으로 볼 수 없는게, 특정 DBMS의 고유 기능을 이용하면 이식성이 저하됨)
  - 프로시저가 많은 시스템에선 ORM 객체 지향적인 장점을 활용하기 어렵다.
    - 이미 프로시저가 많은 시스템에선 다시 객체로 바꿔야하며, 그 과정에서 생산성 저하나 리스크가 많이 발생할 수 있다.

##### JDBC

:: JDBC(Java Database Connectivity)는 DB에 접근할 수 있도록 Java에서 제공하는 API이다.

- JDBC는 관계형 DB에 사용되는 SQL문을 실행하기 위해 자바로 작성된 클래스와 인터페이스로 구성되어 있다.
- 특정 DB나 특정 DB 매커니즘에 구애 받지 않는 독립적인 인터페이스를 통해 다양한 DB에 접근하는 코드를 구현할 수 있도록 제공하는 자바 클래스의 표준 집합이다.
- JDBC클래스는 자바 패키지 java.sql과 javax.sql에 포함되어 있다.

DB 벤더들이 이러한 라이브러리를 각자 만든다면, 자바 프로그래머는 각 벤더가 만든 라이브러리 사용법을 익혀야 할것이다.

[![img](https://github.com/WeareSoft/tech-interview/raw/master/contents/images/jdbc1.png)](https://github.com/WeareSoft/tech-interview/blob/master/contents/images/jdbc1.png)

- JDBC를 이용한 DB 접근
  - 다음과 같은 순서로 이루어진다
    1. JDBC driver 로딩
    2. Connection 맺기
    3. SQL 실행
    4. 자원 반환

1. JDBC driver 로딩
   - driver란? 
     - JDBC driver는 자바 프로그램의 요청을 DBMS가 이해할 수 있는 프로토콜로 변환해주는 클라이언트 사이드 어댑터
2. Connection 맺기
   - DriverManager는 이름 그대로 DB 벤더들이 JDBC API를 구현한 드라이버를 관리한다. DriverManager.getConnection()메서드는 인자로 들어오는 값에 따라서 특정 DB 벤더가 구현한 Connection 타입의 객체를 반환한다. Connection 객체의 생성은 DB와 연결이 확립되었음을 의미한다.
3. SQL 실행
   - 쿼리 실행해서 추출한 값들을 보통 DTO 객체로 변환하여 사용함.
4. 자원 반환

---

##### 용어

- DBMS (Database Management System): 데이터베이스와 사용자 사이에서 관리해주는 소프트웨어

- 스키마 (Schema): 데이터베이스의 구조와 제약 조건에 대한 전반적인 명세를 의미

- ER모델 (개념적 데이터 모델) 
  - 개체(Entity)
    - 파일 시스템의 레코드에 대응
    - DB가 표현하고자 하는 유형, 무형의 정보 대상, 서로 구별됨
    - 물리적 혹은 개념적, 실세계에 독립적으로 존재
  - 속성(attribute)
    - 데이터의 가장 작은 논리적 단위
    - 파일 구조상의 데이터 항목, 또는 데이터 필드
- 릴레이션(relation): 데이터들을 표(table)의 형태로 표현, 같은 성격의 데이터들의 집합을 의미
- 튜플(tuple): 각각의 행은 곧 레코드, 서로 다른 값을 가지며 순서가 없다.
- 속성(attribute): 테이블에서 열을 뜻함, 개체가 가지고 있는 성질, 가장 작은 논리적 단위. 즉, 더이상 쪼갤 수 없는 원자값
- 도메인(domain): 릴레이션을 구성하고 있는 각각의 애트리뷰트가 취할 수 있는 같은 타입의 모든 원자값들의 집합
- 카디널리티(cardinality): 릴레이션에 포함되어 있는 모든 튜플의 수
- 차수(degree): 릴레이션을 구성하는 애트리뷰트의 수
- 슈퍼키(Super Key): 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키, **유일성 만족, 최소성 x**
- 후보키(Candidate Key): 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합. **유일성과 최소성 모두 만족**
- 기본키(Primary Key): 후보키 중에서 특별히 선정된 키로, **중복된 값을 가질 수 없다.**
- 외래키(Foregin Key): **다른 릴레이션을 참조할 때 사용되는 키**, 참조되는 릴레이션의 기본키와 대응, 참조 무결성 제약 조건을 표현하는데 사용되며, 주 릴레이션에 속한 튜플의 기본키 값과 같거나 완전한 NULL이어야 한다.
- NULL: 공백도 아니고 0도 아니고 부재 정보를 나타낸 값.
- 식별 관계: A개체의 기본키가 B의 외래키면서 동시에 기본키 일때
- 비식별관계: 비식별관계는 기본키가 아닐때
- 1:N: 한 개체타입은 여러 개의 개체 어커런스를 가지고 나머지 한개는 하나의 개체 어커런스를 가짐, 릴레이션 A의 기본키를 B의 외래키로 추가하여 표현
- 1:1: 관계이 참여하고 있는 두 개체 타입이 모두 하나씩의 개체 어커런스를 갖는 관계, 릴레이션 A의 기본키를 릴레이션 B의 외래키로 추가 or 반대로 
- N:M: 두 개체 모두 여러개의 개체 어커런스를 가짐, 릴레이션 A와 B의 기본키를 모두 포함한 별도의 릴레이션으로 표현-> 교차엔티티
- 무결성: 권한이 있는 사용자로부터 DB를 보호

##### 정규화 과정 (<u>**원**</u>래도 <u>**완**</u>전 <u>**이**</u>뻤지만 성형<u>**후**</u>에 <u>**다**</u> <u>**조**</u>았다.)

- - **1NF** : 도메인이 <u>**원**</u>자값이다. 
  - **2NF** : 부분적 함수 종속 제거 (<u>**완**</u>전 함수 종속) 
  - **3NF** : <u>**이**</u>행적 함수 종속 제거 
  - **보이스/코드 정규형** **(BCNF)** : 결정자이면서 <u>**후**</u>보키 아닌 것 제거 
  - **4NF** : **<u>다</u>**치 종속 제거 
  - **5NF** : **조**인 종속성 제거

- 